/** Debugging
 *
 * When debugging is required something is broken
 *
 * Reading Error Messages
 *
 * Get use to learning how to carefully read the stack trace
 *
 * TypeError: Cannot read property 'filter' of undefined
    at app.get (/Users/nf/Desktop/meadowlark/meadowlark.js:8:13)
    at Layer.handle [as handle_request] (/Users/nf/Desktop/meadowlark/node_modules/express/lib/router/layer.js:95:5)
    at next (/Users/nf/Desktop/meadowlark/node_modules/express/lib/router/route.js:137:13)
    at Route.dispatch (/Users/nf/Desktop/meadowlark/node_modules/express/lib/router/route.js:112:3)
    at Layer.handle [as handle_request] (/Users/nf/Desktop/meadowlark/node_modules/express/lib/router/layer.js:95:5)
    at /Users/nf/Desktop/meadowlark/node_modules/express/lib/router/index.js:281:22
    at Function.process_params (/Users/nf/Desktop/meadowlark/node_modules/express/lib/router/index.js:335:12)
    at next (/Users/nf/Desktop/meadowlark/node_modules/express/lib/router/index.js:275:10)
    at expressInit (/Users/nf/Desktop/meadowlark/node_modules/express/lib/middleware/init.js:40:5)
    at Layer.handle [as handle_request] (/Users/nf/Desktop/meadowlark/node_modules/express/lib/router/layer.js:95:5)

    the error is at the very top:  TypeError: cannot read property 'filter' of undefined
 *
 * Online Resources:
 * Search Engines
 *  Once error is identified take action, study the error message, and try to walk backwards through the code to understand how the program
 * flow arrived at the erro condition
 *
 * Search the entire message:
 * TypeError: Cannot read property 'filter' of undefined
 *
 * Stack Overflow
 *
 * Documentation
 *
 * Steps to Debugging:
 *
 * 1. Reproduce the error
 *
 * 2. Determine the Boundaries of the Error
 *
 * once you can consistently reproduce the error, it's time to tweak the data that cause the error,
 * ex. the stack trace earlier was generated by this code:
 * data.user.getAll().push(newUser)
 * does calling data.user().getAll() cause the issue?
 * what about calling data.user()?
 * what happens if we try to append an object like this:
 * data.user().getAll.push(anotherUser)?
 * Does modifying the data affect the program behavior? Do we get expected errors, or does a new error occur that sheds light on the problem?
 *
 * This approach lead to deeper understanding of the problem and help us implement better solutions
 *
 * 3. Trace the code:
 *
 * Once you understand the boundaries, its time to trace the code
 */

function car(newCar) {
  let make = getMake(newCar);
  let model = getModel(newCar);
  return [make, model];
}

function getMake(newCar) {
  return newCar.split(" ")[0];
}

function getModel(newCar) {
  return getModel(newCar).split(" ")[2];
}

let [make, model] = car("Ford Mustang");  // array destructuring construct
console.log(make === "Ford"); // => true
console.log(model[0] === "M");  // TypeError: Cannot read property '0' of undefined

// When an array get assigned to two or more variables wrapped in an opening and closing bracket
// the first element get assigned to the first variable and the second get assigned to the second, and so on

// On line 73 we get an error when we try to see whether the value model begins with the character 'M'
// Looks like we have a bug, first let's try to reproduce the problem consistently

[make, model] = car("Mitsubishi Mirage");
console.log(model[0] === "M"); // => TypeError: Cannot read property '0' of undefined

[make, model] = car("Chevy Malibu"); // => TypeError: Cannot read property '0' of undefined

[make, model] = car("Toyota Corolla"); // => TypeError: Cannot read property '0' of undefined

// We can consistently reproduce the problem, and it fails in the same way when we provide an input

/** Let's trace backwards
 * when we call car a string get passed as an argument, represented by the local variable newCar
 * gets passed to the 2 helper functions: getMake and getModel
 * inside each helper, we try to split newCar into two new strings: 'Ford' and 'Mustang'
 * the getMake should return Mustang -> getMake returns the correct value, getModel does not, it returns undefined
 * Based on these observations, the bug originates in the getModel.
 *  identifying the area where an error originates is called Trapping the Error
 */

// 4. Understand the Problem Well

// After narrowing the source of the bg to getModel, it's time to analyze the function code.  We know the return value of this
// function is always undefined.  Let's inspect each step

// function getModel(newCar) {
//   return newCar;  // => "Ford Mustang"
// }

// That's the expected value of newCar, no issues

// function getModel(newCar) {
//   return newCar.split(" ");   // => ["Ford", "Mustang"]
// }

// The return value is an array that contains the strings "Ford" and "Mustang", working as expected

// function getModel(newCar) {
//   return newCar.split(" ")[2];  // => undefined
// }

// the problem come from accessing index 2 since the array has 2 elements the largest index is 1.  no element at index 2

// 5. Implement a Fix
// Tghere are anumber of ways to fix the problem, ex.  We can supress the error
// from being thrown.

// try {
//   return model[0] === "M";
// } catch {
//   return false;
// }

// We'd still have the error, sometimes that's the only solution.  Ex, using a 
// library you can't modify.

// 6. Test the Fix
// Implementing a fix, make sure to verify the code fixed the problem, by using
// similary tests from step #2

/** Techniques For Debugging
 * 
 * 1. Line By Line
 * most bugs come from overlooking a detail rather than a complete isunderstanding 
 * of a concept, developing a habit of reading code line-by-line, word-by-word
 * character by character is the most usefyul programming skill
 * 
 * 2. Rubber Duck
 * Explaining the problem to a duck, force yourself to articulate the problem, detail by detail.
 * That often leads to discovering the root of the problem. it doesn't have to be a rubber duck
 * it can be anything including another person
 * 
 * 3. Walking Away
 * When you walk away your brain is still working on the problem if we spent time loading the problem
 * in our brain, our brain works on the problem even while we sleep, plus twe get tired as well so
 * it's ok to step away
 * 
 * Inspecting with a Debugger
 * 
 * Node comes with a debugger, but sometimes it does conflict with readline-sync
 * to use the debugger run node with the inspect argument
 * 
 * node inspect filename.js
 * 
 * 
 */

